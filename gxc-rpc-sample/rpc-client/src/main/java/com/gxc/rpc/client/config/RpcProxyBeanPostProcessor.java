package com.gxc.rpc.client.config;import com.gxc.rpc.client.annotation.Reference;import com.gxc.rpc.client.factory.RpcProxyFactory;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.BeansException;import org.springframework.beans.factory.config.BeanPostProcessor;import java.lang.reflect.Field;import java.util.HashMap;import java.util.Map;/** * @author GongXincheng * @date 2019-12-10 21:30 */public class RpcProxyBeanPostProcessor implements BeanPostProcessor {    private static final Logger logger = LoggerFactory.getLogger(RpcProxyBeanPostProcessor.class);    private final Map<Class<?>, Object> cache = new HashMap<>();    @Override    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {        return bean;    }    @Override    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {        // 遍历所有的字段        for (Field f : bean.getClass().getDeclaredFields()) {            // 判断是否有 @Reference 注解            if (f.isAnnotationPresent(Reference.class)) {                // 暴力破解                f.setAccessible(true);                // 获取Field的类型                Class<?> clazz = f.getType();                Object proxy = null;                // 判断该字段类型在缓存中是否存在                if (cache.containsKey(clazz)) {                    proxy = cache.get(clazz);                } else {                    // 动态代理生成                    proxy = new RpcProxyFactory<>(clazz).getProxyObject();                    cache.put(clazz, proxy);                }                try {                    // bean 代表当前Field所处的类                    f.set(bean, proxy);                    logger.info("为{}注入{}。", f, proxy);                } catch (Exception e) {                    e.printStackTrace();                    logger.error("属性" + f + "注入失败", e);                }            }        }        return bean;    }}